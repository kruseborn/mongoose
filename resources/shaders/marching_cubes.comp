#version 450
#extension GL_ARB_shading_language_420pack : enable

#include "marching_cube_utils.hglsl"

layout(set = 0, binding = 0) uniform Ubo {
  vec4 corner;
  uvec4 N;
  float cellSize;
} ubo;

layout(set = 0, binding = 1) buffer DrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
} drawIndirectCommand;

layout(set = 1, binding = 0) buffer Density { 
  float x[]; 
} density;

layout(set = 2, binding = 0) buffer A2iTriangleConnectionTable { 
  int x[256][16]; 
} a2iTriangleConnectionTable;

layout(set = 3, binding = 0) buffer AiCubeEdgeFlags { 
  int x[256]; 
} aiCubeEdgeFlags;

struct Triangle {
  vec4 v[6]; // vertices, normals
};

layout(set = 4, binding = 0) writeonly buffer Mesh {
  Triangle triangles[1<<15];
} mesh;


float fGetOffset(float fValue1, float fValue2, float fValueDesired) {
  float fDelta = fValue2 - fValue1;
  if (fDelta == 0.0f) {
    return 0.5f;
  }
  return (fValueDesired - fValue1) / fDelta;
}

#define localGroupSize 256
layout(local_size_x = localGroupSize) in;

 vec3 toPos(uint index, uvec3 size) {
	uint z = index / (size.x * size.y);
  uint y = (index  - (size.x * size.y * z)) / size.x;
	uint x = index - z * size.x * size.y - y * size.x;
  
	return vec3(float(x),float(y),float(z)) * ubo.cellSize + ubo.corner.xyz;
}


float map(vec3 pos) {
  float d = length(pos) - 0.25;
  float d2 = pos.y - (-0.25);
  return min(d, d2);
}

void main() {
//   atomicExchange(drawIndirectCommand.instanceCount, 1);
//  // atomicExchange(drawIndirectCommand.vertexCount, 0);
//   // memoryBarrierBuffer();
//   // barrier();
//   // memoryBarrier();

  const uint size = ubo.N.x * ubo.N.y * ubo.N.z;
	uint index = gl_GlobalInvocationID.x;

  while(index < size) {
    const uint currentIndex = index;
		index += gl_NumWorkGroups.x * localGroupSize;

    float afCubeValue[8];
    vec3 asEdgeVertex[12];

    uint flagIndex = 0;
    const vec3 pos = toPos(currentIndex, ubo.N.xyz);
    for (uint i = 0; i < 8; i++) {
      vec3 cornerPos = pos + vertexOffset[i] * ubo.cellSize;
      afCubeValue[i] = map(cornerPos);
      if (afCubeValue[i] < 0.0) {
        flagIndex |= 1 << i;
      }
    }

    // Find which edges are intersected by the surface
    int edgeFlags = aiCubeEdgeFlags.x[flagIndex];
    if (edgeFlags == 0) {
      continue;
    }
    // Find the point of intersection of the surface with each edge
    // Then find the normal to the surface at those points
    for (uint i = 0; i < 12; i++) {
      // if there is an intersection on this edge
      if ((edgeFlags & (1 << i)) != 0) {
        float fOffset =
            fGetOffset(afCubeValue[a2iEdgeConnection[i][0]], afCubeValue[a2iEdgeConnection[i][1]], 0.0f);

        asEdgeVertex[i] =
            pos + (a2fVertexOffset[a2iEdgeConnection[i][0]] + fOffset * a2fEdgeDirection[i]) * ubo.cellSize;
      }
    }
    for (uint i = 0; i < 5; i++) {
      if (a2iTriangleConnectionTable.x[flagIndex][3 * i] < 0)
        break;
      Triangle triangle;
      for (uint j = 0; j < 3; j++) {
        int vertexIndex = a2iTriangleConnectionTable.x[flagIndex][3 * i + j];
        //vertices.push_back(glm::vec4(asEdgeVertex[vertexIndex], 1.0f));
        //vertices.push_back(glm::vec4(getNormal(asEdgeVertex[vertexIndex]), 1.0f));
        triangle.v[j*2] = vec4(asEdgeVertex[vertexIndex], 1.0);
        triangle.v[j*2 + 1] = vec4(1,1,0,1);
      }
      uint vertexCount = atomicAdd(drawIndirectCommand.vertexCount, 3) / 3;
      mesh.triangles[vertexCount] = triangle;
    }
  }
}

