#version 450
#extension GL_ARB_shading_language_420pack : enable

layout (set = 0, binding = 0) uniform UBO {
	float deltaT;
	int particleCount;

} ubo;

struct Particle {
	vec4 position;
	vec4 velocity;
};
layout(set = 1, binding = 0) buffer Storage {
   Particle particles[];
} storage;

const int SHARED_DATA_SIZE = 256;

shared vec4 sharedData[SHARED_DATA_SIZE];

layout (local_size_x = 256) in;

void main() {
	const int index = int(gl_GlobalInvocationID);
  
  vec4 position = storage.particles[index].position;
	vec3 acceleration = vec3(0.0);

	for (int i = 0; i < ubo.particleCount; i += SHARED_DATA_SIZE) {
		if (i + gl_LocalInvocationID.x < ubo.particleCount)
			sharedData[gl_LocalInvocationID.x] = storage.particles[gl_LocalInvocationID.x + i].position;


		memoryBarrierShared();
		barrier();
    vec3 body1 = position.xyz;
		for (int j = 0; j < gl_WorkGroupSize.x; j++) {
      vec4 body2 = sharedData[j];

      vec3 r =  body2.xyz - body1;
      float distSqr = dot(r,r) + 0.005; // Softening factor;;

      distSqr = pow(distSqr, 0.5);

      float s = body2.w * 1.0 / distSqr;
			acceleration.xyz +=  r * s;
      // vec4 other = sharedData[j];
			// vec3 r = other.xyz - position.xyz;
			// float f = 1 / pow(dot(r, r) + 0.005, 0.5);
      // acceleration.xyz += f * 0.002 * r * other.w;
		}

		memoryBarrierShared();
		barrier();
	}

	storage.particles[index].velocity.xyz += ubo.deltaT * acceleration;
	storage.particles[index].velocity.xyz *= 0.99;


	storage.particles[index].velocity.w += 0.1 * ubo.deltaT;
	if (storage.particles[index].velocity.w > 1.0)
		storage.particles[index].velocity.w -= 1.0;
}