#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_control_flow_attributes : require

struct StorageData {
	vec4 positions[5];
	vec4 albedos[5];
};

layout (set = 0, binding = 0) uniform Ubo {
	// mat4 model;
	// mat4 view;
	// mat4 projection;
	// mat4 modelIT;
	mat4 viewInverse;
	mat4 projInverse;
} ubo;

uint InitRandomSeed(uint val0, uint val1) {
	uint v0 = val0, v1 = val1, s0 = 0;

	[[unroll]] 
	for (uint n = 0; n < 16; n++)
	{
		s0 += 0x9e3779b9;
		v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);
		v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);
	}
	return v0;
}

uint RandomInt(inout uint seed) {
	// LCG values from Numerical Recipes
    return (seed = 1664525 * seed + 1013904223);
}

float RandomFloat(inout uint seed) {
	// Float version using bitmask from Numerical Recipes
	const uint one = 0x3f800000;
	const uint msk = 0x007fffff;
	return uintBitsToFloat(one | (msk & (RandomInt(seed) >> 9))) - 1;
}

vec3 RandomInUnitSphere(inout uint seed) {
	for (;;) {
		const vec3 p = 2 * vec3(RandomFloat(seed), RandomFloat(seed), RandomFloat(seed)) - 1;
		if (dot(p, p) < 1) {
			return p;
		}
	}
}

struct PayLoad {
	vec4 attenuation;
	vec4 scatterDirection;
	uint seed;
};

@gen
layout(set = 1, binding = 0, rgba8) uniform image2D image;
layout(set = 2, binding = 0) uniform accelerationStructureNV topLevelAS;

layout(location = 0) rayPayloadNV PayLoad payload;

void main() {
	vec2 pixelCenter  = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
	vec2 inUV = pixelCenter / vec2(gl_LaunchSizeNV.xy);
	inUV.y = 1 - inUV.y;
	vec2 ndc = inUV * 2.0 - 1.0;

	uint seed = InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y);
	payload.seed = seed;
	vec3 color = vec3(0);
	int samples = 10;
	for(uint i = 0; i < samples; i++) {
		vec2 offset = vec2(RandomFloat(seed), RandomFloat(seed));
		vec4 origin = ubo.viewInverse * vec4(0,0,0,1);
	//	vec4 target = ubo.projInverse * vec4(ndc.x, ndc.y, 1, 1);
		vec4 target = ubo.projInverse * vec4(ndc.x + offset.x/gl_LaunchSizeNV.x, ndc.y+ offset.y/gl_LaunchSizeNV.y, 1, 1);
		vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz), 0);

		uint rayFlags = gl_RayFlagsOpaqueNV;
		uint cullMask = 0xff;
		float tmin = 0.001;
		float tmax = 1000.0;

		vec3 bounceColor = vec3(1);
		 for(int i = 0; i < 5; i++) {
		 	traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin.xyz, tmin, direction.xyz, tmax, 0);
		 	bounceColor *= payload.attenuation.xyz;

		 	if(payload.attenuation.w < 0) break;
		 	origin = origin + direction * payload.scatterDirection.w;
		 	direction.xyz = payload.scatterDirection.xyz;
		 }
		color += bounceColor;
	}
	color = color/samples;
	color = sqrt(color);
	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(color, 1.0));
}

@miss
layout(location = 0) rayPayloadInNV PayLoad payload;

void main()  {
		float t = 0.5*(normalize(gl_WorldRayDirectionNV).y + 1);
		payload.attenuation.xyz = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
		payload.attenuation.w = -1;
}

@proc-int
hitAttributeNV vec4 hitAttribute;

layout(set = 0, binding = 1) readonly buffer Storage {
	 StorageData storageData; 
} storage;


void main()
{
	vec4 position = storage.storageData.positions[gl_InstanceCustomIndexNV];
	vec3 center = position.xyz;
	float radius = position.w;
	
	vec3 origin = gl_WorldRayOriginNV;
	vec3 direction = gl_WorldRayDirectionNV;
	float tMin = gl_RayTminNV;
	float tMax = gl_RayTmaxNV;

	vec3 oc = origin - center;
	float a = dot(direction, direction);
	float b = dot(oc, direction);
	float c = dot(oc, oc) - radius * radius;
	float discriminant = b * b - a * c;

	if (discriminant >= 0) {
		float t1 = (-b - sqrt(discriminant)) / a;
		float t2 = (-b + sqrt(discriminant)) / a;

		if ((tMin <= t1 && t1 < tMax) || (tMin <= t2 && t2 < tMax))
		{
			hitAttribute = position;
			reportIntersectionNV((tMin <= t1 && t1 < tMax) ? t1 : t2, 0);
		}
	}
}

@proc-chit lambert
hitAttributeNV vec4 hitAttribute;
layout(location = 0) rayPayloadInNV PayLoad payload;
layout(set = 2, binding = 0) uniform accelerationStructureNV topLevelAS;

layout(set = 0, binding = 1) readonly buffer Storage {
	 StorageData storageData; 
} storage;

void main() {
	vec4 albedo = storage.storageData.albedos[gl_InstanceCustomIndexNV];
	vec3 center = hitAttribute.xyz;
	float radius = hitAttribute.w;
	vec3 hitPoint = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;

	vec3 normal = (hitPoint - center) / radius;

	payload.attenuation = albedo;
	payload.scatterDirection = vec4(normal + RandomInUnitSphere(payload.seed), gl_HitTNV);
}

@proc-chit metal

layout(set = 0, binding = 1) readonly buffer Storage {
	 StorageData storageData; 
} storage;

hitAttributeNV vec4 hitAttribute;
layout(location = 0) rayPayloadInNV PayLoad payload;
layout(set = 2, binding = 0) uniform accelerationStructureNV topLevelAS;

void main() {
	vec4 albedo = storage.storageData.albedos[gl_InstanceCustomIndexNV];

	vec3 center = hitAttribute.xyz;
	float radius = hitAttribute.w;
	vec3 hitPoint = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
	vec3 normal = (hitPoint - center) / radius;

	vec3 reflected = reflect(gl_WorldRayDirectionNV, normal);
	payload.scatterDirection = vec4(reflected + RandomInUnitSphere(payload.seed)*albedo.w, gl_HitTNV);
	payload.attenuation = albedo;
	payload.attenuation.w = dot(reflected, normal) > 0? 1: -1;
}

@proc-chit dielectrics

bool refract(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted) {
	vec3 uv = normalize(v);
	float dt = dot(uv, n);
	float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1 - dt*dt);
	if(discriminant > 0) {
		refracted = ni_over_nt*(uv - n*dt)- n*sqrt(discriminant);
		return true;
	}
	else
		return false;
}

float schlick(float cosine, float ref_idx) {
	float r0 = (1-ref_idx) / (1+ref_idx);
	r0 = r0*r0;
	return r0 + (1-r0) * pow((1- cosine), 5);
}

layout(set = 0, binding = 1) readonly buffer Storage {
	 StorageData storageData; 
} storage;

hitAttributeNV vec4 hitAttribute;
layout(location = 0) rayPayloadInNV PayLoad payload;
layout(set = 2, binding = 0) uniform accelerationStructureNV topLevelAS;

void main() {
	vec4 albedo = storage.storageData.albedos[gl_InstanceCustomIndexNV];

	vec3 center = hitAttribute.xyz;
	float radius = hitAttribute.w;
	vec3 hitPoint = gl_WorldRayOriginNV + gl_WorldRayDirectionNV * gl_HitTNV;
	vec3 normal = (hitPoint - center) / radius;

	float ref_idx = albedo.w;
	vec3 outwardNormal;
	vec3 reflected = reflect(gl_WorldRayDirectionNV, normal);
	float ni_over_nt;
	payload.attenuation = vec4(1,1,1,1);
	vec3 refracted;
	float reflect_prob;
	float cosine;
	if(dot(gl_WorldRayDirectionNV, normal) > 0) {
		outwardNormal = -normal;
		ni_over_nt = ref_idx;
		cosine = ref_idx * dot(gl_WorldRayDirectionNV, normal) / length(gl_WorldRayDirectionNV);
	} else {
		outwardNormal = normal;
		ni_over_nt = 1 / ref_idx;
		cosine = -dot(gl_WorldRayDirectionNV, normal) / length(gl_WorldRayDirectionNV);
	}
	if(refract(gl_WorldRayDirectionNV, outwardNormal, ni_over_nt, refracted)) {
		reflect_prob = schlick(cosine, ref_idx);
	} else {
		payload.scatterDirection = vec4(reflected, gl_HitTNV);
		reflect_prob = 1;
	}
	if(RandomFloat(payload.seed) < reflect_prob) {
		payload.scatterDirection = vec4(reflected, gl_HitTNV);
	} else {
		payload.scatterDirection = vec4(refracted, gl_HitTNV);
	}
}