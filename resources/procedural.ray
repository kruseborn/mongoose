#version 460
#extension GL_NV_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "Random.hglsl"

struct RayPayload {
	vec4 ColorAndDistance; // xyz + t
	vec4 ScatterDirection; // xyz + w (is scatter needed)
	uint RandomSeed;
};

struct UniformBufferObject {
	mat4 ModelView;
	mat4 Projection;
	mat4 ModelViewInverse;
	mat4 ProjectionInverse;
	float Aperture;
	float FocusDistance;
	uint TotalNumberOfSamples;
	uint NumberOfSamples;
	uint NumberOfBounces;
	uint RandomSeed;
	bool GammaCorrection;
	bool HasSky;
};

@gen
layout(set = 0, binding = 0) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(set = 1, binding = 0, rgba8) uniform image2D OutputImage;
layout(set = 2, binding = 0) uniform accelerationStructureNV Scene;


layout(location = 0) rayPayloadNV RayPayload Ray;

void main() 
{
	// Initialise separate random seeds for the pixel and the rays.
	// - pixel: we want the same random seed for each pixel to get a homogeneous anti-aliasing.
	// - ray: we want a noisy random seed, different for each pixel.
	uint pixelRandomSeed = Camera.RandomSeed;
	Ray.RandomSeed = InitRandomSeed(InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y), Camera.TotalNumberOfSamples);

	vec3 pixelColor = vec3(0);

	// Accumulate all the rays for this pixels.
	for (uint s = 0; s < Camera.NumberOfSamples; ++s)
	{
		//if (Camera.NumberOfSamples != Camera.TotalNumberOfSamples) break;
		const vec2 pixel = vec2(gl_LaunchIDNV.x + RandomFloat(pixelRandomSeed), gl_LaunchIDNV.y + RandomFloat(pixelRandomSeed));
		const vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;

		vec2 offset = Camera.Aperture/2 * RandomInUnitDisk(Ray.RandomSeed);
		vec4 origin = Camera.ModelViewInverse * vec4(offset, 0, 1);
		vec4 target = Camera.ProjectionInverse * (vec4(uv.x, uv.y, 1, 1));
		vec4 direction = Camera.ModelViewInverse * vec4(normalize(target.xyz * Camera.FocusDistance - vec3(offset, 0)), 0);
		vec3 rayColor = vec3(1);

		// Ray scatters are handled in this loop. There are no recursive traceNV() calls in other shaders.
		for (uint b = 0; b < Camera.NumberOfBounces; ++b)
		{
			const float tMin = 0.001;
			const float tMax = 10000.0;

			traceNV(
				Scene, gl_RayFlagsOpaqueNV, 0xff, 
				0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, 
				origin.xyz, tMin, direction.xyz, tMax, 0 /*payload*/);
			
			const vec3 hitColor = Ray.ColorAndDistance.rgb;
			const float t = Ray.ColorAndDistance.w;
			const bool isScattered = Ray.ScatterDirection.w > 0;

			rayColor *= hitColor;

			// Trace missed, or end of trace.
			if (t < 0 || !isScattered)
			{				
				break;
			}

			// Trace hit.
			origin = origin + t * direction;
			direction = vec4(Ray.ScatterDirection.xyz, 0);
		}

		pixelColor += rayColor;
	}

	const bool accumulate = Camera.NumberOfSamples != Camera.TotalNumberOfSamples;
	const vec3 accumulatedColor = (accumulate ? imageLoad(AccumulationImage, ivec2(gl_LaunchIDNV.xy)) : vec4(0)).rgb + pixelColor;

	pixelColor = accumulatedColor / Camera.TotalNumberOfSamples;

	if (Camera.GammaCorrection)
	{
		// Apply raytracing-in-one-weekend gamma correction.
		pixelColor = sqrt(pixelColor);
	}

	imageStore(AccumulationImage, ivec2(gl_LaunchIDNV.xy), vec4(accumulatedColor, 0));
    imageStore(OutputImage, ivec2(gl_LaunchIDNV.xy), vec4(pixelColor, 0));
}


@miss
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject Camera; };
layout(location = 0) rayPayloadInNV RayPayload Ray;

void main()
{
	if (Camera.HasSky)
	{
		// Sky color
		const float t = 0.5*(normalize(gl_WorldRayDirectionNV).y + 1);
		const vec3 skyColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);

		Ray.ColorAndDistance = vec4(skyColor, -1);
	}
	else
	{
		Ray.ColorAndDistance = vec4(0, 0, 0, -1);
	}
}


@hit
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };

hitAttributeNV vec2 HitAttributes;
rayPayloadInNV RayPayload Ray;

vec3 Mix(vec3 a, vec3 b, vec3 c, vec3 barycentrics) 
{
    return a * barycentrics.x + b * barycentrics.y + c * barycentrics.z;
}
void main()
{
	// Get the material.
	// const uvec2 offsets = Offsets[gl_InstanceCustomIndexNV];
	// const uint indexOffset = offsets.x;
	// const uint vertexOffset = offsets.y;
	// const Vertex v0 = UnpackVertex(vertexOffset + Indices[indexOffset + gl_PrimitiveID * 3 + 0]);
	// const Vertex v1 = UnpackVertex(vertexOffset + Indices[indexOffset + gl_PrimitiveID * 3 + 1]);
	// const Vertex v2 = UnpackVertex(vertexOffset + Indices[indexOffset + gl_PrimitiveID * 3 + 2]);
	// const Material material = Materials[v0.MaterialIndex];

	// Compute the ray hit point properties.
	const vec3 barycentrics = vec3(1.0 - HitAttributes.x - HitAttributes.y, HitAttributes.x, HitAttributes.y);
	const vec3 normal = normalize(Mix(v0.Normal, v1.Normal, v2.Normal, barycentrics));

	Ray = RayPayload(vec4(barycentrics, 0.5), vec4(normal,0), 10);
}

@proc-int
layout(binding = 8) readonly buffer SphereArray { vec4[] Spheres; };

hitAttributeNV vec4 Sphere;

void main()
{
	const vec4 sphere = Spheres[gl_InstanceCustomIndexNV];
	const vec3 center = sphere.xyz;
	const float radius = sphere.w;
	
	const vec3 origin = gl_WorldRayOriginNV;
	const vec3 direction = gl_WorldRayDirectionNV;
	const float tMin = gl_RayTminNV;
	const float tMax = gl_RayTmaxNV;

	// https://en.wikipedia.org/wiki/Quadratic_formula

	const vec3 oc = origin - center;
	const float a = dot(direction, direction);
	const float b = dot(oc, direction);
	const float c = dot(oc, oc) - radius * radius;
	const float discriminant = b * b - a * c;

	if (discriminant >= 0)
	{
		const float t1 = (-b - sqrt(discriminant)) / a;
		const float t2 = (-b + sqrt(discriminant)) / a;

		if ((tMin <= t1 && t1 < tMax) || (tMin <= t2 && t2 < tMax))
		{
			Sphere = sphere;
			reportIntersectionNV((tMin <= t1 && t1 < tMax) ? t1 : t2, 0);
		}
	}
}

@proc-chit
layout(binding = 4) readonly buffer VertexArray { float Vertices[]; };
layout(binding = 5) readonly buffer IndexArray { uint Indices[]; };
layout(binding = 6) readonly buffer MaterialArray { Material[] Materials; };
layout(binding = 7) readonly buffer OffsetArray { uvec2[] Offsets; };
layout(binding = 8) readonly buffer SphereArray { vec4[] Spheres; };

hitAttributeNV vec4 Sphere;
rayPayloadInNV RayPayload Ray;

vec2 GetSphereTexCoord(const vec3 point)
{
	const float phi = atan(point.x, point.z);
	const float theta = asin(point.y);
	const float pi = 3.1415926535897932384626433832795;

	return vec2
	(
		1 - (phi + pi) / (2* pi),
		(theta + pi /2) / pi
	);
}

void main()
{
	// // Get the material.
	// const uvec2 offsets = Offsets[gl_InstanceCustomIndexNV];
	// const uint indexOffset = offsets.x;
	// const uint vertexOffset = offsets.y;
	// const Vertex v0 = UnpackVertex(vertexOffset + Indices[indexOffset]);
	// const Material material = Materials[v0.MaterialIndex];

	// // Compute the ray hit point properties.
	// const vec4 sphere = Spheres[gl_InstanceCustomIndexNV];
	// const vec3 center = sphere.xyz;
	// const float radius = sphere.w;
	// const vec3 point = gl_WorldRayOriginNV + gl_HitTNV * gl_WorldRayDirectionNV;
	// const vec3 normal = (point - center) / radius;
	// const vec2 texCoord = GetSphereTexCoord(normal);

	Ray = RayPayload(vec4(1,0,0, 0.5), vec4(0,1,0,0), 10);
}